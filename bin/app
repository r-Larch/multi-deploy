#!/usr/bin/env bash
# Multi-deploy app manager
# Usage:
#   app create            # interactive app setup
#   app enable <name>     # enable & start systemd timer
#   app disable <name>    # disable & stop systemd timer
#   app remove <name>     # disable timer and delete app
#   app update <name>     # git fetch/pull if changed, then up (no forced rebuild)
#   app deploy <name>     # build & up (force deploy)
#   app start <name>      # compose up -d
#   app stop <name>       # compose down
#   app restart <name>    # compose restart
#   app logs <name> [svc] # compose logs
#   app list              # list apps and status
set -euo pipefail

INSTALL_DIR=${INSTALL_DIR:-/opt/multi-deploy}
APPS_DIR="$INSTALL_DIR/apps"

bold() { echo -e "\e[1m$*\e[0m"; }
red() { echo -e "\e[31m$*\e[0m"; }

default_read() {
  local prompt="$1"; shift || true
  local default_value="${1:-}"; shift || true
  local var
  if [[ -n "$default_value" ]]; then
    read -r -p "$prompt [$default_value]: " var || true
    echo "${var:-$default_value}"
  else
    read -r -p "$prompt: " var || true
    echo "$var"
  fi
}

require_bin() {
  command -v "$1" >/dev/null 2>&1 || { red "Missing dependency: $1"; exit 1; }
}

confirm() {
  local prompt="${1:-Proceed?}"; shift || true
  read -r -p "$prompt [y/N]: " ans || true
  [[ "${ans,,}" == y || "${ans,,}" == yes ]]
}

slugify() {
  # Keep lowercase letters, digits and dashes
  echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9-]+/-/g; s/^-+//; s/-+$//'
}

find_compose_file() {
  # Look for common compose filenames in repo root
  local repo_dir="$1"
  local -a candidates=(docker-compose.yml docker-compose.yaml compose.yml compose.yaml)
  local found=()
  for f in "${candidates[@]}"; do
    if [[ -f "$repo_dir/$f" ]]; then found+=("$f"); fi
  done
  if (( ${#found[@]} == 1 )); then
    echo "${found[0]}"; return 0
  elif (( ${#found[@]} > 1 )); then
    echo "Multiple compose files found:" >&2
    local i=1
    for f in "${found[@]}"; do echo "  [$i] $f" >&2; ((i++)); done
    while true; do
      read -r -p "Select compose file number: " idx || true
      if [[ "$idx" =~ ^[0-9]+$ ]] && (( idx>=1 && idx<=${#found[@]} )); then
        echo "${found[idx-1]}"; return 0
      fi
      echo "Invalid selection" >&2
    done
  fi
  return 1
}

list_services_from_compose() {
  # Best-effort parse of top-level service keys from a compose file
  local compose_path="$1"
  awk '
    /^[ \t]*services:[ \t]*$/ {in_s=1; base=match($0,/[^ ]/)-1; next}
    in_s==1 {
      # End of services block when indentation goes back to base and next key starts
      if ($0 !~ /^[ \t]*$/ && match($0,/[^ ]/)-1 <= base && $0 !~ /^[ \t]*#/ && $0 !~ /^[ \t]*-/) { exit }
      if (match($0,/^([ \t]{2,})([A-Za-z0-9_.-]+):[ \t]*$/, m)) {
        ind=length(m[1]);
        if (!svc_ind) svc_ind=ind;
        if (ind==svc_ind) print m[2];
      }
    }
  ' "$compose_path" | sort -u
}

extract_traefik_labels() {
  # Grep traefik labels present in the compose file (best-effort)
  local compose_path="$1"
  grep -n "traefik\." "$compose_path" || true
}

ensure_dirs() {
  mkdir -p "$APPS_DIR"
}

load_app() {
  local name="$1"
  APP_META_DIR="$APPS_DIR/$name"
  APP_ENV="$APP_META_DIR/app.env"
  APP_REPO_DIR="$APP_META_DIR/code"
  if [[ ! -f "$APP_ENV" ]]; then red "Missing $APP_ENV"; exit 1; fi
  # shellcheck disable=SC1090
  source "$APP_ENV"
  if [[ -z "${COMPOSE_FILE:-}" ]]; then red "COMPOSE_FILE not set in $APP_ENV"; exit 1; fi
  APP_COMPOSE_FILE="$APP_META_DIR/$COMPOSE_FILE"
}

build_compose_cmd() {
  compose_cmd=(docker compose)
  compose_cmd+=(-f "$APP_COMPOSE_FILE")
}

ensure_repo() {
  # Clone if repo missing, using existing watch-and-deploy logic
  if [[ ! -d "$APP_REPO_DIR/.git" ]]; then
    echo "Cloning repo for app '$NAME' into $APP_REPO_DIR ..."
    "$INSTALL_DIR/bin/watch-and-deploy.sh" "$REPO" "$NAME" "$BRANCH" "$COMPOSE_FILE"
  fi
}

cmd_create() {
  require_bin git
  ensure_dirs

  echo
  bold "New app setup"

  local name repo branch
  name=$(default_read "App name (slug)" "")
  name=$(slugify "$name")
  if [[ -z "$name" ]]; then red "App name required"; exit 1; fi

  repo=$(default_read "Git repo URL (SSH)" "git@github.com:org/repo.git")
  if [[ -z "$repo" ]]; then red "Repo URL required"; exit 1; fi

  branch=$(default_read "Git branch" "main")
  if [[ -z "$branch" ]]; then branch=main; fi

  # Paths per layout:
  # - metadata and stack files in $INSTALL_DIR/apps/<name>
  # - repo worktree in $INSTALL_DIR/apps/<name>/code
  local meta_dir="$APPS_DIR/$name"
  local repo_dir="$APPS_DIR/$name/code"

  # Create meta dir and repo dir
  if [[ -e "$meta_dir" ]]; then
    echo "Directory $meta_dir already exists."
    if ! confirm "Continue and reuse it?"; then exit 1; fi
  fi
  mkdir -p "$meta_dir"

  if [[ -d "$repo_dir/.git" ]]; then
    echo "Repo already present at $repo_dir. Fetching updates..."
    (cd "$repo_dir" && git fetch --all --prune)
  else
    echo "Cloning $repo into $repo_dir ..."
    mkdir -p "$repo_dir"
    git clone "$repo" "$repo_dir"
  fi

  # Robust checkout of branch
  (
    cd "$repo_dir"
    git fetch --all --prune
    if git show-ref --verify --quiet "refs/heads/$branch"; then
      git checkout "$branch"
      git pull --ff-only || true
    elif git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
      git checkout -B "$branch" --track "origin/$branch"
      git pull --ff-only || true
    else
      red "Branch '$branch' not found on origin. Staying on current branch." || true
    fi
  )

  # Detect a compose file in repo root (optional; for selecting service)
  local compose_file_repo=""
  if compose_file_repo=$(find_compose_file "$repo_dir"); then
    echo "Detected compose file in repo: $compose_file_repo"
  else
    echo "No compose file found in repo root. You can add one under code/."
  fi

  # List services for selection (if compose found)
  local svc=""
  if [[ -n "$compose_file_repo" ]]; then
    echo
    echo "Detecting services in $compose_file_repo ..."
    mapfile -t services < <(list_services_from_compose "$repo_dir/$compose_file_repo")
    if (( ${#services[@]} > 0 )); then
      echo "Found services: ${services[*]}"
      echo
      echo "Select the service to attach to Traefik (network+enable only):"
      local i=1
      for s in "${services[@]}"; do echo "  [$i] $s"; ((i++)); done
      while true; do
        read -r -p "Service number: " idx || true
        if [[ "$idx" =~ ^[0-9]+$ ]] && (( idx>=1 && idx<=${#services[@]} )); then
          svc="${services[idx-1]}"; break
        fi
        echo "Invalid selection"
      done
    fi
  fi

  # Write app.env into meta dir
  local env_path="$meta_dir/app.env"
  cat >"$env_path" <<EOF
# Auto-generated by app create
NAME=$name
REPO=$repo
BRANCH=$branch
COMPOSE_FILE=compose.yml
EOF

  # Write compose.yml in meta dir with include of repo compose and server override
  local stack_compose="$meta_dir/compose.yml"
  if [[ -n "$compose_file_repo" ]]; then
    cat >"$stack_compose" <<EOF
include:
  - path:
      - code/$compose_file_repo
      - compose.server.yml
EOF
  else
    cat >"$stack_compose" <<EOF
include:
  - path:
      - compose.server.yml
EOF
  fi

  # Write minimal compose.server.yml override
  local override_path="$meta_dir/compose.server.yml"
  if [[ -n "$svc" ]]; then
    cat >"$override_path" <<EOF
services:
  $svc:
    networks:
      - web
    labels:
      - "traefik.enable=true"

networks:
  web:
    external: true
    name: web
EOF
  else
    # If no service known yet, create a template and leave TODO
    cat >"$override_path" <<'EOF'
# Select a service name from your repo's compose and uncomment below
# services:
#   app:
#     networks:
#       - web
#     labels:
#       - "traefik.enable=true"

networks:
  web:
    external: true
    name: web
EOF
  fi

  echo
  bold "Review"
  echo "App meta dir:  $meta_dir"
  echo "Repo worktree:     $repo_dir"
  echo "Repo URL:          $repo"
  echo "Branch:            $branch"
  echo "Stack compose:     $stack_compose"
  echo "override compose:  $override_path"

  echo
  bold "Next steps"
  echo "- cd $repo_dir"
  echo "- Configure your app if required (env, secrets, migrations, etc.)"
  echo "- Then enable deployments: $(basename "$0") enable $name"

  bold "Done. App '$name' created."
}

cmd_enable() {
  local name=${1:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") enable <name>"; exit 1; fi
  if [[ ${EUID:-$UID} -ne 0 ]]; then
    sudo systemctl enable --now "multi-deploy@${name}.timer"
  else
    systemctl enable --now "multi-deploy@${name}.timer"
  fi
  echo "Enabled timer for '$name'"
}

cmd_disable() {
  local name=${1:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") disable <name>"; exit 1; fi
  if [[ ${EUID:-$UID} -ne 0 ]]; then
    sudo systemctl disable --now "multi-deploy@${name}.timer"
  else
    systemctl disable --now "multi-deploy@${name}.timer"
  fi
  echo "Disabled timer for '$name'"
}

cmd_remove() {
  local name=${1:-}
  local app_dir="$APPS_DIR/$name"
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") remove <name>"; exit 1; fi
  if [[ ! -d "$app_dir" ]]; then red "App '$name' not found at $app_dir"; exit 1; fi
  bold "Disabling timer for '$name'..."
  if [[ ${EUID:-$UID} -ne 0 ]]; then
    sudo systemctl disable --now "multi-deploy@${name}.timer"
  else
    systemctl disable --now "multi-deploy@${name}.timer"
  fi
  bold "Removing app directory: $app_dir"
  rm -rf "$app_dir"
  # Remove example app if present
  if [[ "$name" == "example" && -d "$APPS_DIR/example" ]]; then
    rm -rf "$APPS_DIR/example"
    echo "Example app removed."
  fi
  echo "App '$name' removed."
}

cmd_deploy() {
  local name=${1:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") deploy <name>"; exit 1; fi
  load_app "$name"
  ensure_repo
  build_compose_cmd
  echo "Building images..."
  "${compose_cmd[@]}" build --pull
  echo "Applying stack..."
  "${compose_cmd[@]}" up -d --remove-orphans
  echo "Deployed '$name'"
}

cmd_update() {
  local name=${1:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") update <name>"; exit 1; fi
  load_app "$name"
  ensure_repo
  # Use watcher path that calls deploy.sh with change detection (no forced build)
  "$INSTALL_DIR/bin/watch-and-deploy.sh" "$REPO" "$NAME" "$BRANCH" "$COMPOSE_FILE"
}

cmd_detail() {
  local name=${1:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") detail <name>"; exit 1; fi
  load_app "$name"
  echo "File: $APP_ENV"
  echo "----"
  sed 's/^/    /' "$APP_ENV" || true
  echo
  echo "File: $APP_COMPOSE_FILE"
  echo "----"
  if [[ -f "$APP_COMPOSE_FILE" ]]; then
    sed 's/^/    /' "$APP_COMPOSE_FILE"
  else
    echo "    (missing)"
  fi
}

cmd_start() {
  local name=${1:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") start <name>"; exit 1; fi
  load_app "$name"
  ensure_repo
  build_compose_cmd
  "${compose_cmd[@]}" up -d
  echo "Started '$name'"
}

cmd_stop() {
  local name=${1:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") stop <name>"; exit 1; fi
  load_app "$name"
  ensure_repo
  build_compose_cmd
  "${compose_cmd[@]}" down
  echo "Stopped '$name'"
}

cmd_restart() {
  local name=${1:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") restart <name>"; exit 1; fi
  load_app "$name"
  ensure_repo
  build_compose_cmd
  # Prefer compose restart for speed
  "${compose_cmd[@]}" restart || { "${compose_cmd[@]}" up -d --force-recreate; }
  echo "Restarted '$name'"
}

cmd_logs() {
  local name=${1:-}
  local svc=${2:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") logs <name> [service]"; exit 1; fi
  load_app "$name"
  ensure_repo
  build_compose_cmd
  if [[ -n "$svc" ]]; then
    "${compose_cmd[@]}" logs -f --tail=200 "$svc"
  else
    "${compose_cmd[@]}" logs -f --tail=200
  fi
}

cmd_list() {
  ensure_dirs
  printf "%-24s %-12s %-18s\n" "NAME" "AUTO-DEPLOY" "CONTAINERS"
  printf "%-24s %-12s %-18s\n" "------------------------" "------------" "------------------"
  local d name envf auto out lines running total
  for d in "$APPS_DIR"/*; do
    [[ -d "$d" ]] || continue
    envf="$d/app.env"
    [[ -f "$envf" ]] || continue
    name="$(basename "$d")"
    # Auto-deploy (timer) status
    if systemctl --quiet is-enabled "multi-deploy@${name}.timer" 2>/dev/null; then
      auto="enabled"
    else
      auto="disabled"
    fi
    # Container status
    # shellcheck disable=SC1090
    source "$envf" || true
    APP_META_DIR="$d"
    APP_REPO_DIR="$d/code"
    APP_COMPOSE_FILE="$APP_META_DIR/${COMPOSE_FILE:-compose.yml}"
    build_compose_cmd || true
    out=$({ "${compose_cmd[@]}" ps 2>/dev/null || true; } | sed '/^$/d')
    if [[ -z "$out" || ! -f "$APP_COMPOSE_FILE" ]]; then
      printf "%-24s %-12s %-18s\n" "$name" "$auto" "stopped"
      continue
    fi
    # Count containers excluding header row
    lines=$(echo "$out" | awk 'NR>1 {print}' | wc -l | tr -d ' ')
    if [[ "$lines" == "0" ]]; then
      printf "%-24s %-12s %-18s\n" "$name" "$auto" "stopped"
      continue
    fi
    running=$(echo "$out" | grep -i "running" | wc -l | tr -d ' ')
    total="$lines"
    printf "%-24s %-12s %-18s\n" "$name" "$auto" "running ${running}/${total}"
  done
}

usage() {
  cat <<USAGE
Usage:
  $(basename "$0") create            # interactive app setup
  $(basename "$0") enable <name>     # enable & start systemd timer
  $(basename "$0") disable <name>    # disable & stop systemd timer
  $(basename "$0") remove <name>     # disable timer and delete app
  $(basename "$0") update <name>     # git fetch/pull if changed, then up (no forced rebuild)
  $(basename "$0") deploy <name>     # build & up (force deploy)
  $(basename "$0") start <name>      # compose up -d
  $(basename "$0") stop <name>       # compose down
  $(basename "$0") restart <name>    # compose restart
  $(basename "$0") logs <name> [svc] # compose logs
  $(basename "$0") list              # list apps and status
  $(basename "$0") detail <name>     # print app.env and compose.yml
USAGE
}

main() {
  local cmd=${1:-}
  case "$cmd" in
    create) shift || true; cmd_create "$@" ;;
    enable) shift || true; cmd_enable "$@" ;;
    disable) shift || true; cmd_disable "$@" ;;
    remove) shift || true; cmd_remove "$@" ;;
    update) shift || true; cmd_update "$@" ;;
    deploy) shift || true; cmd_deploy "$@" ;;
    start)  shift || true; cmd_start "$@" ;;
    stop)   shift || true; cmd_stop "$@" ;;
    restart)shift || true; cmd_restart "$@" ;;
    logs)   shift || true; cmd_logs "$@" ;;
    list)   shift || true; cmd_list "$@" ;;
    detail) shift || true; cmd_detail "$@" ;;
    -h|--help|help|"") usage ;;
    *) red "Unknown command: $cmd"; echo; usage; exit 1 ;;
  esac
}

main "$@"
