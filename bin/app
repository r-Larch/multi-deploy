#!/usr/bin/env bash
# Multi-deploy app manager
# Usage:
#   app create [name]      # interactive app setup (name optional)
#   app delete <name>      # disable timer and delete app
#   app update <name>      # git fetch/pull if changed, then up (no forced rebuild)
#   app deploy <name>      # build & up (force deploy)
#   app up <name>          # compose up -d
#   app down <name>        # compose down
#   app restart <name>     # compose restart
#   app logs <name> [svc]  # compose logs
#   app list               # list apps and status
#   app detail <name>      # show detailed app info
#   app pull <name>        # only git fetch/reset to origin/<branch>
#   app shell <name> <svc> # open shell in running container
#   app run <name> ...args # run raw docker compose args
set -euo pipefail

INSTALL_DIR=${INSTALL_DIR:-/opt/multi-deploy}
APPS_DIR="$INSTALL_DIR/apps"

# Require shared library
# shellcheck disable=SC1091
source "$INSTALL_DIR/bin/lib-app" || { echo "Missing $INSTALL_DIR/bin/lib-app" >&2; exit 1; }

find_compose_file() {
  # Look for common compose filenames in repo root
  local repo_dir="$1"
  local -a candidates=(docker-compose.yml docker-compose.yaml compose.yml compose.yaml)
  local found=()
  for f in "${candidates[@]}"; do
    if [[ -f "$repo_dir/$f" ]]; then found+=("$f"); fi
  done
  if (( ${#found[@]} == 1 )); then
    echo "${found[0]}"; return 0
  elif (( ${#found[@]} > 1 )); then
    echo "Multiple compose files found:" >&2
    local i=1
    for f in "${found[@]}"; do echo "  [$i] $f" >&2; ((i++)); done
    while true; do
      read -r -p "Select compose file number: " idx || true
      if [[ "$idx" =~ ^[0-9]+$ ]] && (( idx>=1 && idx<=${#found[@]} )); then
        echo "${found[idx-1]}"; return 0
      fi
      echo "Invalid selection" >&2
    done
  fi
  return 1
}

list_services_from_compose() {
  # Best-effort parse of top-level service keys from a compose file
  local compose_path="$1"
  awk '
    /^[ \t]*services:[ \t]*$/ {in_s=1; base=match($0,/[^ ]/)-1; next}
    in_s==1 {
      # End of services block when indentation goes back to base and next key starts
      if ($0 !~ /^[ \t]*$/ && match($0,/[^ ]/)-1 <= base && $0 !~ /^[ \t]*#/ && $0 !~ /^[ \t]*-/) { exit }
      if (match($0,/^([ \t]{2,})([A-Za-z0-9_.-]+):[ \t]*$/, m)) {
        ind=length(m[1]);
        if (!svc_ind) svc_ind=ind;
        if (ind==svc_ind) print m[2];
      }
    }
  ' "$compose_path" | sort -u
}

extract_traefik_labels() {
  # Grep traefik labels present in the compose file (best-effort)
  local compose_path="$1"
  grep -n "traefik\." "$compose_path" || true
}

ensure_dirs() {
  mkdir -p "$APPS_DIR"
}

load_app() {
  local name="$1"
  APP_META_DIR="$APPS_DIR/$name"
  APP_ENV="$APP_META_DIR/app.env"
  APP_REPO_DIR="$APP_META_DIR/code"
  if [[ ! -f "$APP_ENV" ]]; then red "Missing $APP_ENV"; exit 1; fi
  # shellcheck disable=SC1090
  source "$APP_ENV"
  if [[ -z "${COMPOSE_FILE:-}" ]]; then red "COMPOSE_FILE not set in $APP_ENV"; exit 1; fi
  APP_COMPOSE_FILE="$APP_META_DIR/$COMPOSE_FILE"
}

build_compose_cmd() {
  compose_cmd=(docker compose)
  compose_cmd+=(-f "$APP_COMPOSE_FILE")
}

ensure_repo() {
  # Clone if repo missing, using existing watch-and-deploy logic
  if [[ ! -d "$APP_REPO_DIR/.git" ]]; then
    echo "Cloning repo for app '$NAME' into $APP_REPO_DIR ..."
    "$INSTALL_DIR/bin/watch-and-deploy.sh" "$REPO" "$NAME" "$BRANCH" "$COMPOSE_FILE"
  fi
}

cmd_create() {
  require_bin git
  ensure_dirs

  echo
  bold "New app setup"

  local name repo branch
  if [[ -n "${1:-}" ]]; then
    name=$(slugify "$1"); shift || true
  else
    name=$(default_read "App name (slug)" "")
    name=$(slugify "$name")
  fi
  if [[ -z "$name" ]]; then red "App name required"; exit 1; fi
  
  if [[ -n "${1:-}" ]]; then
    repo=$1; shift || true
  else
    repo=$(default_read "Git repo URL (SSH, leave empty for static app)" "")
  fi
  branch=""
  if [[ -n "$repo" ]]; then
    branch=$(default_read "Git branch" "main")
    [[ -z "$branch" ]] && branch=main
  fi

  local meta_dir="$APPS_DIR/$name"
  local repo_dir="$APPS_DIR/$name/code"
  local ssh_dir="$APPS_DIR/$name/.ssh"
  mkdir -p "$meta_dir"

  local compose_file_repo=""
  local svc=""
  if [[ -n "$repo" ]]; then
    if [[ -d "$repo_dir/.git" ]]; then
      echo "Repo already present at $repo_dir. Fetching updates..."
      (cd "$repo_dir" && git fetch --all --prune)
    else
      # Helpful: show deploy key if using SSH
      if [[ "$repo" =~ ^(git@|ssh://) ]]; then
        ensure_app_ssh_key "$ssh_dir"
        bold "Deploy key (add to your Git hosting as read-only):"
        cat "$ssh_dir/id_ed25519.pub"
        echo
        read -r -p "Press Enter to continue with git clone..." || true
      fi

      echo "Cloning $repo into $repo_dir ..."
      mkdir -p "$repo_dir"
      git clone "$repo" "$repo_dir"
    fi

    # git config core.sshCommand '/usr/bin/ssh -i ${APP_SSH_DIR}/id_ed25519 -o IdentitiesOnly=yes' 

    (
      cd "$repo_dir"
      git fetch --all --prune
      if git show-ref --verify --quiet "refs/heads/$branch"; then
        git checkout "$branch"
        git pull --ff-only || true
      elif git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
        git checkout -B "$branch" --track "origin/$branch"
        git pull --ff-only || true
      else
        red "Branch '$branch' not found on origin. Staying on current branch." || true
      fi
    )
    if compose_file_repo=$(find_compose_file "$repo_dir"); then
      echo "Detected compose file in repo: $compose_file_repo"
      echo
      echo "Detecting services in $compose_file_repo ..."
      mapfile -t services < <(list_services_from_compose "$repo_dir/$compose_file_repo")
      if (( ${#services[@]} > 0 )); then
        echo "Found services: ${services[*]}"
        echo
        echo "Select the service to attach to Traefik (network+enable only):"
        local i=1
        for s in "${services[@]}"; do echo "  [$i] $s"; ((i++)); done
        while true; do
          read -r -p "Service number: " idx || true
          if [[ "$idx" =~ ^[0-9]+$ ]] && (( idx>=1 && idx<=${#services[@]} )); then
            svc="${services[idx-1]}"; break
          fi
          echo "Invalid selection"
        done
      fi
    fi
  fi

  # app.env
  local env_path="$meta_dir/app.env"
  {
    echo "# Auto-generated by app create"
    echo "NAME=$name"
    [[ -n "$repo" ]] && echo "REPO=$repo"
    [[ -n "$branch" ]] && echo "BRANCH=$branch"
    echo "COMPOSE_FILE=compose.yml"
  } > "$env_path"

  # compose.yml
  local stack_compose="$meta_dir/compose.yml"
  if [[ -n "$compose_file_repo" ]]; then
    cat >"$stack_compose" <<EOF
include:
  - path:
      - code/$compose_file_repo
      - compose.server.yml
EOF
  else
    # static app (no git): only server override placeholder
    cat >"$stack_compose" <<'EOF'
include:
  - path:
      - compose.server.yml
EOF
  fi

  # compose.server.yml
  local override_path="$meta_dir/compose.server.yml"
  if [[ -n "$svc" ]]; then
    cat >"$override_path" <<EOF
services:
  $svc:
    networks:
      - web
    labels:
      - "traefik.enable=true"
      #- "traefik.http.routers.myapp.rule=Host(\`myapp-domain.com\`)"
      #- "traefik.http.routers.myapp.entrypoints=websecure"
      #- "traefik.http.routers.myapp.tls.certresolver=letsencrypt"

networks:
  web:
    external: true
    name: web
EOF
  else
    cat >"$override_path" <<'EOF'
# Select a service name from your repo's compose and uncomment below
# services:
#   app:
#     networks:
#       - web
#     labels:
#       - "traefik.enable=true"
#       - "traefik.http.routers.myapp.rule=Host(\`myapp-domain.com\`)"
#       - "traefik.http.routers.myapp.entrypoints=websecure"
#       - "traefik.http.routers.myapp.tls.certresolver=letsencrypt"

networks:
  web:
    external: true
    name: web
EOF
  fi

  echo
  bold "Review"
  echo "App dir:           $meta_dir"
  echo "Repo worktree:     $repo_dir"
  echo "Repo URL:          ${repo:-"(static app)"}"
  [[ -n "$branch" ]] && echo "Branch:            $branch"
  echo "Stack compose:     $stack_compose"
  echo "override compose:  $override_path"

  echo
  bold "Next steps"
  if [[ -n "$repo" ]]; then
    echo "- cd $repo_dir"
    echo "- Configure your app if required (env, secrets, migrations, etc.)"
    echo "- Then enable deployments: $(basename "$0") timers $name on"
  else
    echo "- Edit $override_path and add your service under services:"
  fi

  bold "Done. App '$name' created."
}

cmd_delete() { cmd_remove "$@"; }
cmd_remove() {
  local name=${1:-}; [[ -n "$name" ]] || { red "Usage: $(basename "$0") delete <name>"; exit 1; }
  local dir="$APPS_DIR/$name"
  if [[ ! -d "$dir" ]]; then red "App not found: $name"; exit 1; fi
  if confirm "Delete app '$name' at $dir? This cannot be undone."; then
    if systemctl is-enabled "multi-deploy@${name}.timer" >/dev/null 2>&1; then
      systemctl disable --now "multi-deploy@${name}.timer" || true
    fi
    rm -rf "$dir"
    echo "Deleted $name"
  else
    echo "Aborted"
  fi
}

cmd_update() { local n=${1:-}; [[ -n "$n" ]] || { red "Usage: $(basename "$0") update <name>"; exit 1; }; "$INSTALL_DIR/bin/app-deploy" "$n" update; }
cmd_deploy() { local n=${1:-}; [[ -n "$n" ]] || { red "Usage: $(basename "$0") deploy <name>"; exit 1; }; "$INSTALL_DIR/bin/app-deploy" "$n" deploy; }
cmd_up() { local n=${1:-}; [[ -z "$n" ]] && { red "Usage: $(basename "$0") up <name>"; exit 1; }; "$INSTALL_DIR/bin/app-compose" "$n" up -d; }
cmd_down() { local n=${1:-}; [[ -z "$n" ]] && { red "Usage: $(basename "$0") down <name>"; exit 1; }; "$INSTALL_DIR/bin/app-compose" "$n" down; }
cmd_pull() { local n=${1:-}; [[ -z "$n" ]] && { red "Usage: $(basename "$0") pull <name>"; exit 1; }; "$INSTALL_DIR/bin/app-git" "$n" pull; }
cmd_git() { local n=${1:-}; shift || true; [[ -z "$n" ]] && { red "Usage: $(basename "$0") git <name> <git-command>"; exit 1; }; "$INSTALL_DIR/bin/app-git" "$n" "$@"; }
cmd_run() { local n=${1:-}; shift || true; [[ -z "$n" ]] && { red "Usage: $(basename "$0") run <name> <compose-args...>"; exit 1; }; "$INSTALL_DIR/bin/app-compose" "$n" "$@"; }
cmd_shell() { local n=${1:-}; local svc=${2:-}; [[ -z "$n" || -z "$svc" ]] && { red "Usage: $(basename "$0") shell <name> <service>"; exit 1; }; "$INSTALL_DIR/bin/app-compose" "$n" exec -it "$svc" sh; }

cmd_restart() {
  local n=${1:-}; [[ -n "$n" ]] || { red "Usage: $(basename "$0") restart <name>"; exit 1; }
  if "$INSTALL_DIR/bin/app-compose" "$n" restart; then
    exit 0
  else
    echo "Restart failed; trying up --force-recreate"
    "$INSTALL_DIR/bin/app-compose" "$n" up -d --force-recreate
  fi
}

cmd_logs() {
  local n=${1:-}; shift || true
  [[ -n "$n" ]] || { red "Usage: $(basename "$0") logs <name> [service]"; exit 1; }
  if [[ -n "${1:-}" ]]; then
    "$INSTALL_DIR/bin/app-compose" "$n" logs -f --tail=200 "$1"
  else
    "$INSTALL_DIR/bin/app-compose" "$n" logs -f --tail=200
  fi
}

cmd_ci_logs() {
  local name=${1:-}
  [[ -n "$name" ]] || { red "Usage: $(basename "$0") ci-logs <name>"; exit 1; }
  load_app "$name"
  local log_dir="$APP_META_DIR/logs"
  mkdir -p "$log_dir"
  bold "Streaming deploy logs for '$name' (Ctrl-C to exit)"
  echo "Log directory: $log_dir"
  local last_file="" tail_pid=""
  # Clean up background tail on exit
  trap '[[ -n ${tail_pid:-} ]] && kill "$tail_pid" 2>/dev/null || true' EXIT INT TERM
  while true; do
    # Find newest log file
    local newest=""
    newest=$(ls -1t "$log_dir"/*.log 2>/dev/null | head -n1 || true)
    if [[ -z "$newest" ]]; then
      printf '[%s] Waiting for first log file...\n' "$(date -Is)"
      sleep 2
      continue
    fi
    if [[ "$newest" != "$last_file" ]]; then
      # Switch to new file
      if [[ -n "$tail_pid" ]]; then
        kill "$tail_pid" 2>/dev/null || true
        wait "$tail_pid" 2>/dev/null || true
        echo
      fi
      if [[ -z "$last_file" ]]; then
        echo "Current log: $(basename "$newest")"
      else
        echo "---- Switched to new log: $(basename "$newest") ----"
      fi
      last_file="$newest"
      # Tail from beginning for context; could change to -n 200 if too verbose
      tail -n +1 -F "$newest" &
      tail_pid=$!
    fi
    sleep 2
  done
}

cmd_list() {
  ensure_dirs
  printf "%-20s %-8s %-14s\n" "NAME" "TIMER" "STATUS"
  printf "%-20s %-8s %-14s\n" "----" "-----" "------"
  for d in "$APPS_DIR"/*; do
    [[ -d "$d" ]] || continue
    local name=$(basename "$d")
    if [[ ! -f "$d/app.env" ]]; then continue; fi
    # Load context
    NAME="$name"; APP_META_DIR="$d"; APP_ENV="$d/app.env"; source "$APP_ENV" || true
    # Timer state
    local timer="n/a"
    if [[ -n "${REPO:-}" ]]; then
      if systemctl --quiet is-enabled "multi-deploy@${name}.timer" 2>/dev/null; then timer="on"; else timer="off"; fi
    fi
    # Compose status via shared helper
    APP_COMPOSE_FILE="$d/${COMPOSE_FILE:-compose.yml}"
    build_compose_cmd
    local status; status=$(print_compose_status)
    printf "%-20s %-8s %-14s\n" "$name" "$timer" "$status"
  done
}

cmd_timers() {
  local name=${1:-}; local action=${2:-}
  [[ -n "$name" ]] || { red "Usage: $(basename "$0") timers <name> [on|off]"; exit 1; }
  load_app "$name"
  if [[ -z "${REPO:-}" ]]; then
    echo "Timers: n/a (static app)"
    return 0
  fi
  if [[ -z "$action" ]]; then
    if systemctl --quiet is-enabled "multi-deploy@${NAME}.timer" 2>/dev/null; then echo "Timers: on"; else echo "Timers: off"; fi
    return 0
  fi
  case "$action" in
    on)  systemctl daemon-reload || true; systemctl enable --now "multi-deploy@${NAME}.timer"; echo "Timers enabled" ;;
    off) systemctl disable --now "multi-deploy@${NAME}.timer" || true; echo "Timers disabled" ;;
    *) red "Usage: $(basename "$0") timers <name> [on|off]"; exit 1 ;;
  esac
}

cmd_detail() {
  local name=${1:-}
  local svc=${2:-}
  if [[ -z "$name" ]]; then red "Usage: $(basename "$0") detail <name> [service]"; exit 1; fi
  load_app "$name"
  local type="static"
  if [[ -n "${REPO:-}" ]]; then type="git"; fi
  local timers
  if systemctl --quiet is-enabled "multi-deploy@${NAME}.timer" 2>/dev/null; then timers="on"; else timers="off"; fi
  echo "App directory: $APP_META_DIR"
  echo "Type: $type  Timers: $timers"
  if [[ "$type" == git ]]; then
    # Reuse centralized git status logic (app-git) to avoid drift
    local git_status
    git_status=$("$INSTALL_DIR/bin/app-git" "$name" status 2>/dev/null || true)
    [[ -n "$git_status" ]] && echo "Git: $git_status" || echo "Git: (unavailable)"
  fi
  echo
  if [[ -z "$svc" ]]; then
    echo "Services:"
    "$INSTALL_DIR/bin/app-compose" "$name" config --services 2>/dev/null | sed 's/^/  - /'
    echo
    echo "docker compose config (summary)"
    "$INSTALL_DIR/bin/app-compose" "$name" config 2>/dev/null | sed -n '1,80p' || true
  else
    echo "docker compose config for service '$svc'"
    "$INSTALL_DIR/bin/app-compose" "$name" config 2>/dev/null | awk -v svc="$svc" '
      $0 ~ /^services:/ {in_s=1; next}
      in_s {
        if ($0 ~ /^[^ ]/) exit
        if ($0 ~ /^  [^ ]+:/) {
          cur=$0; sub(/^  /,"",cur); sub(/:.*/,"",cur)
          if (found && cur!=svc) exit
          if (cur==svc) {found=1; print; next}
        }
        if (found) print
      }
    '
  fi
}

usage() {
  cat <<USAGE
Usage:
  $(basename "$0") create [name]     # interactive app setup
  $(basename "$0") delete <name>     # disable timer and delete app
  $(basename "$0") timers <name> [on|off] # get/set timer state
  $(basename "$0") update <name>     # git fetch/pull if changed, then up
  $(basename "$0") deploy <name>     # build & up (force deploy)
  $(basename "$0") up <name>         # compose up -d
  $(basename "$0") down <name>       # compose down
  $(basename "$0") restart <name>    # compose restart
  $(basename "$0") logs <name> [svc] # compose logs
  $(basename "$0") ci-logs <name>    # stream deploy logs (auto-rollover)
  $(basename "$0") list              # list apps and status
  $(basename "$0") detail <name> [service] # show detailed app info
  $(basename "$0") pull <name>       # only git fetch/reset to origin/<branch>
  $(basename "$0") git <name> <cmd>  # run git commands in app context
  $(basename "$0") shell <name> <svc># open shell in running container
  $(basename "$0") run <name> ...    # run raw docker compose args
USAGE
}

main() {
  local cmd=${1:-}
  case "$cmd" in
    create) shift || true; cmd_create "$@" ;;
    remove|delete) shift || true; cmd_delete "$@" ;;
    timers) shift || true; cmd_timers "$@" ;;
    update) shift || true; cmd_update "$@" ;;
    deploy) shift || true; cmd_deploy "$@" ;;
    up)     shift || true; cmd_up "$@" ;;
    down)   shift || true; cmd_down "$@" ;;
    restart)shift || true; cmd_restart "$@" ;;
    logs)   shift || true; cmd_logs "$@" ;;
  ci-logs)shift || true; cmd_ci_logs "$@" ;;
    list)   shift || true; cmd_list "$@" ;;
    detail) shift || true; cmd_detail "$@" ;;
    pull)   shift || true; cmd_pull "$@" ;;
    git)    shift || true; cmd_git "$@" ;;
    shell)  shift || true; cmd_shell "$@" ;;
    run)    shift || true; cmd_run "$@" ;;
    -h|--help|help|"") usage ;;
    *) red "Unknown command: $cmd"; echo; usage; exit 1 ;;
  esac
}

main "$@"
